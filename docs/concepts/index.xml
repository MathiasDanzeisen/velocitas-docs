<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Eclipse Velocitas â€“ Concepts</title>
    <link>/velocitas-deocs/docs/concepts/</link>
    <description>Recent content in Concepts on Eclipse Velocitas</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 09 May 2022 14:24:56 +0530</lastBuildDate>
    
	  <atom:link href="/velocitas-deocs/docs/concepts/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Velocitas Development Model</title>
      <link>/velocitas-deocs/docs/concepts/development-model/</link>
      <pubDate>Mon, 09 May 2022 13:45:12 +0530</pubDate>
      
      <guid>/velocitas-deocs/docs/concepts/development-model/</guid>
      <description>
        
        
        &lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The Velocitas development model is centered around what are known as &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt;. Automation allows engineers to make high-impact changes frequently and deploy &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; through cloud backends as over-the-air updates. The &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle App&lt;/a&gt; development model is about &lt;em&gt;speed&lt;/em&gt; and &lt;em&gt;agility&lt;/em&gt; paired with state-of-the-art software quality.&lt;/p&gt;
&lt;h2 id=&#34;development-architecture&#34;&gt;Development Architecture&lt;/h2&gt;
&lt;p&gt;Velocitas provides a flexible development architecture for &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt;. The following diagram shows the major components of the Velocitas stack.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/velocitas-deocs/assets/programming_model.drawio.svg&#34; alt=&#34;overview&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;vehicle-apps&#34;&gt;Vehicle Apps&lt;/h3&gt;
&lt;p&gt;The Vehicle Applications (aka. &lt;code&gt;Vehicle Apps&lt;/code&gt;) contain the business logic that needs to be executed on a vehicle. A Vehicle App is implemented on top of a &lt;a href=&#34;#vehicle-models&#34;&gt;Vehicle Model&lt;/a&gt; and its underlying language-specific &lt;a href=&#34;#sdks&#34;&gt;SDK&lt;/a&gt;. Many concepts of cloud-native and &lt;a href=&#34;https://12factor.net/&#34;&gt;twelve-factor&lt;/a&gt; applications apply to &lt;code&gt;Vehicle Apps&lt;/code&gt; as well and are summarized in the next chapter.&lt;/p&gt;
&lt;h3 id=&#34;vehicle-models&#34;&gt;Vehicle Models&lt;/h3&gt;
&lt;p&gt;A Vehicle Model makes it possible to easily get vehicle data from the &lt;a href=&#34;#vehicle-data-broker&#34;&gt;Vehicle Data Broker&lt;/a&gt; and to execute remote procedure calls over gRPC against &lt;a href=&#34;#vehicle-services&#34;&gt;Vehicle Services&lt;/a&gt; and other &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt;. It is generated from the underlying &lt;a href=&#34;#semantic-models&#34;&gt;semantic models&lt;/a&gt; for a concrete programming language as a graph-based, strongly-typed, intellisense-enabled library. The elements of the vehicle models are defined in the &lt;a href=&#34;#sdks&#34;&gt;SDKs&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;sdks&#34;&gt;SDKs&lt;/h3&gt;
&lt;p&gt;To reduce the effort required to implement &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt;, Velocitas provides a set of SDKs for different programming languages. A first SDK is available for Python, further SDKs for Rust and C/C++ are planned.
Next to a &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; abstraction, the SDKs are &lt;a href=&#34;#middleware&#34;&gt;Middleware&lt;/a&gt;-enabled, provide connectivity to the &lt;a href=&#34;#vehicle-data-broker&#34;&gt;Vehicle Data Broker&lt;/a&gt; and contain the ontology in the form of base classes to create &lt;a href=&#34;#vehicle-models&#34;&gt;Vehicle Models&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;vehicle-services&#34;&gt;Vehicle Services&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Vehicle Services&lt;/code&gt; provide service interfaces to control actuators or to trigger (complex) actions. E.g. they communicate with the vehicle internals networks like CAN or Ethernet, which are connected to actuators, electronic control units (ECUs) and other vehicle computers (VCs). They may provide a simulation mode to run without a network interface. &lt;code&gt;Vehicle services&lt;/code&gt; may feed data to the &lt;a href=&#34;#vehicle-data-broker&#34;&gt;Vehicle Data Broker&lt;/a&gt; and may expose gRPC endpoints, which can be invoked by &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; over a &lt;a href=&#34;#vehicle-models&#34;&gt;Vehicle Model&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;vehicle-data-broker&#34;&gt;Vehicle Data Broker&lt;/h3&gt;
&lt;p&gt;Vehicle data is stored in the &lt;code&gt;Vehicle Data Broker&lt;/code&gt; conforming to an underlying &lt;a href=&#34;#semantic-models&#34;&gt;Semantic Model&lt;/a&gt; like VSS. &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; can either pull this data or subscribe for updates. In addition, it supports rule-based access to reduce the number of updates sent. The storage of the vehicle data broker will be the vehicle twin that syncs its data to the cloud.&lt;/p&gt;
&lt;h3 id=&#34;semantic-models&#34;&gt;Semantic models&lt;/h3&gt;
&lt;p&gt;The Vehicle Signal Specification (&lt;a href=&#34;https://covesa.github.io/vehicle_signal_specification/&#34;&gt;VSS&lt;/a&gt;) provides a domain taxonomy for vehicle signals and defines the vehicle data semantically, which is exchanged between &lt;code&gt;Vehicle Apps&lt;/code&gt; and the &lt;code&gt;vehicle data broker&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Vehicle Service Catalog (&lt;a href=&#34;https://github.com/COVESA/vehicle_service_catalog#vehicle-service-catalog&#34;&gt;VSC&lt;/a&gt;) extends VSS with functional remote procedure call definitions and semantically defines the gRPC interfaces of &lt;code&gt;Vehicle Services&lt;/code&gt; and &lt;code&gt;Vehicle Apps&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As an alternative to VSS and VSC, vehicle data and services can be defined semantically in a general IoT modelling language like Digital Twin Definition Language (&lt;a href=&#34;https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md&#34;&gt;DTDL&lt;/a&gt;) or BAMM Aspect Meta Model &lt;a href=&#34;https://github.com/OpenManufacturingPlatform/sds-bamm-aspect-meta-model&#34;&gt;BAMM&lt;/a&gt; as well.&lt;/p&gt;
&lt;h3 id=&#34;communication-protocols&#34;&gt;Communication Protocols&lt;/h3&gt;
&lt;p&gt;Asynchronous communication between &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; and other vehicle components as well as cloud connectivity is facilitated through &lt;a href=&#34;https://mqtt.org/&#34;&gt;MQTT&lt;/a&gt; messaging. Direct, synchronous communication between &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt;, &lt;a href=&#34;#vehicle-services&#34;&gt;Vehicle Services&lt;/a&gt; and the &lt;a href=&#34;#vehicle-data-broker&#34;&gt;Vehicle Data Broker&lt;/a&gt; is based on the &lt;a href=&#34;https://grpc.io/&#34;&gt;gRPC&lt;/a&gt; protocol.&lt;/p&gt;
&lt;h3 id=&#34;middleware&#34;&gt;Middleware&lt;/h3&gt;
&lt;p&gt;Velocitas leverages &lt;a href=&#34;https://dapr.io&#34;&gt;dapr&lt;/a&gt; for gRPC service discovery, Open Telemetry tracing and the &lt;a href=&#34;https://docs.dapr.io/developing-applications/building-blocks/pubsub/pubsub-overview/&#34;&gt;publish/subscribe building block&lt;/a&gt; as a higher-level abstraction over MQTT messaging.&lt;/p&gt;
&lt;h3 id=&#34;vehicle-edge-operating-system&#34;&gt;Vehicle Edge Operating System&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; are expected to run on a &lt;a href=&#34;https://www.linux.org/&#34;&gt;Linux&lt;/a&gt;-based operating system. An OCI-compliant container runtime is required to host the Vehicle App containers and the dapr middleware mandates a Kubernetes control plane. For publish/subscribe messaging a MQTT broker must be available (e.g., &lt;a href=&#34;https://mosquitto.org/&#34;&gt;Eclipse Mosquitto&lt;/a&gt;).&lt;/p&gt;
&lt;h2 id=&#34;vehicle-app-characteristics&#34;&gt;Vehicle App characteristics&lt;/h2&gt;
&lt;h3 id=&#34;code-base&#34;&gt;Code Base&lt;/h3&gt;
&lt;p&gt;Every &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle App&lt;/a&gt; is stored in its own repository. Tracked with version control, it can be deployed to multiple environments.&lt;/p&gt;
&lt;h3 id=&#34;polyglot&#34;&gt;Polyglot&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; can be written in any programming language. System-level programming languages like Rust and C/C++ are particularly relevant for limited hardware resources found in vehicles, but higher-level languages like Python and JavaScript are also considered for special use cases.&lt;/p&gt;
&lt;h3 id=&#34;oci-compliant-containers&#34;&gt;OCI-compliant containers&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; are deployed as OCI-compliant containers. The size of these containers should be minimal to fit on constrained devices.&lt;/p&gt;
&lt;h3 id=&#34;isolation&#34;&gt;Isolation&lt;/h3&gt;
&lt;p&gt;Each &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle App&lt;/a&gt; should execute in its own process and should be self-contained with its interfaces and functionality exposed on its own port.&lt;/p&gt;
&lt;h3 id=&#34;configurations&#34;&gt;Configurations&lt;/h3&gt;
&lt;p&gt;Configuration information is moved out of the &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle App&lt;/a&gt;, so that the same deployment can propagate across environments with the correct configuration applied.&lt;/p&gt;
&lt;h3 id=&#34;disposability&#34;&gt;Disposability&lt;/h3&gt;
&lt;p&gt;Favor fast startup and support graceful shutdowns to leave the system in a correct state.&lt;/p&gt;
&lt;h3 id=&#34;observability&#34;&gt;Observability&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; provide traces, metrics and logs of every part of the application using &lt;em&gt;Open Telemetry&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;over-the-air-updatability&#34;&gt;Over-the-air updatability&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; are released to cloud backends like the &lt;a href=&#34;https://www.bosch-mobility-solutions.com/en/solutions/software-and-services/mobility-cloud/&#34;&gt;Bosch Mobility Cloud&lt;/a&gt; and can be updated in vehicles frequently over the air.&lt;/p&gt;
&lt;h2 id=&#34;development-process&#34;&gt;Development Process&lt;/h2&gt;
&lt;p&gt;The starting point for developing &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle Apps&lt;/a&gt; is a &lt;a href=&#34;#semantic-models&#34;&gt;Semantic Model&lt;/a&gt; of the vehicle data and vehicle services. Based on the &lt;a href=&#34;#semantic-models&#34;&gt;Semantic Model&lt;/a&gt;, language-specific &lt;a href=&#34;#vehicle-models&#34;&gt;Vehicle Models&lt;/a&gt; are generated. &lt;a href=&#34;#vehicle-models&#34;&gt;Vehicle Models&lt;/a&gt; are then distributed as packages to the respective package manager of the chosen programming language (e.g. pip, cargo, npm, &amp;hellip;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/velocitas-deocs/assets/build_procedure.drawio.svg&#34; alt=&#34;Procedure&#34;&gt;&lt;/p&gt;
&lt;p&gt;After a &lt;a href=&#34;#vehicle-models&#34;&gt;Vehicle Model&lt;/a&gt; is available for the chosen programming language, the &lt;a href=&#34;#vehicle-apps&#34;&gt;Vehicle App&lt;/a&gt; can be developed using the generated Vehicle Model and its core SDK.&lt;/p&gt;
&lt;h2 id=&#34;next-steps&#34;&gt;Next steps&lt;/h2&gt;
&lt;h3 id=&#34;vehicle-apps-sdk-documentation&#34;&gt;Vehicle Apps SDK Documentation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/velocitas-deocs/python-sdk/python_vehicle_app_sdk_overview.md&#34;&gt;Python SDK Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Coming soon: Rust SDK Overview&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;working-with-vehicle-models&#34;&gt;Working with Vehicle Models&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Walkthrough: &lt;a href=&#34;/velocitas-deocs/docs/python-sdk/tutorial_how_to_create_a_vehicle_model.md&#34;&gt;Creating a Python Vehicle Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Coming soon: Creating a Rust Vehicle Model&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;working-with-vehicle-apps&#34;&gt;Working with Vehicle Apps&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Walkthrough: &lt;a href=&#34;/velocitas-deocs/docs/python-sdk/tutorial_how_to_create_a_vehicle_app.md&#34;&gt;Creating a Python Vehicle App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Coming soon: Creating a Rust Vehicle App&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Build and Release Process</title>
      <link>/velocitas-deocs/docs/concepts/vehicle_app_releases/</link>
      <pubDate>Mon, 09 May 2022 13:43:25 +0530</pubDate>
      
      <guid>/velocitas-deocs/docs/concepts/vehicle_app_releases/</guid>
      <description>
        
        
        &lt;p&gt;The Velocitas project provides a two-stage process for the development, continuous integration, and release of a new version of a Vehicle App.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stage 1 - Build &amp;amp; Test&lt;/strong&gt;
On every new push to the &lt;code&gt;main&lt;/code&gt; branch, a GitHub workflow is automatically executed to build your application as a container (optionally for different platforms), runs automated tests and code quality checks, and stores all results as GitHub artifacts or in a container registry for future reference.&lt;/p&gt;
&lt;p&gt;The workflow provides quick feedback during development and improves efficient collaboration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stage 2 - Release&lt;/strong&gt;
Once the application is ready to be released in a new version, a dedicated release workflow is automatically executed as soon as you create a new release via GitHub.&lt;/p&gt;
&lt;p&gt;The workflow bundles all relevant artifacts into one tagged set of files and makes it possible to push this information to the preferred OTA (over-the-air update) system of your choice or use the information for quality assurance and documentation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following illustrates the different workflows, actions and artifacts that are automatically created for you. Both workflows are intended as a sensible baseline and can be extended and adapted to your own project&amp;rsquo;s needs.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/velocitas-deocs/assets/publish_container.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ci-workflow-ciyml&#34;&gt;CI Workflow (ci.yml)&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;CI workflow&lt;/code&gt; is triggered on every commit to the main branch and contains a set of different actions that cover:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Building a container for the app&lt;/strong&gt; - actions create a containerized version of the Vehicle App, the actions also support creating an image for multiple platforms.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scanning for vulnerabilities&lt;/strong&gt; - actions scan your code and container for vulnerabilities and in case of findings the workflow will be marked as &amp;ldquo;failed&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Running unit tests &amp;amp; code coverage&lt;/strong&gt; - actions run unit tests and calculate code coverage for your application, in case of errors or unsatisfactory code coverage, the workflow will be marked as &amp;ldquo;failed&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Running integration tests&lt;/strong&gt; - actions provision a runtime and deploy all required services as containers together with your containerized application to allow for automatically executing integration test cases. In case the test cases fail, the workflow will be marke as &amp;ldquo;failed&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Storing scan &amp;amp; test results as GitHub action artifacts&lt;/strong&gt; - actions store results from the previously mentioned actions for further reference or download as Github Action Artifacts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Publish container images to GitHub Container Registry&lt;/strong&gt; - at the end of the workflow, the container images created are stored in a Github Container Registry so that they can be referenced by the release-workflow later.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;release-workflow-releaseyml&#34;&gt;Release Workflow (release.yml)&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Release workflow&lt;/code&gt; is triggered as soon as the &lt;code&gt;main&lt;/code&gt; branch is ready for release and the Vehicle App developer creates a new GitHub release. This can be done manually through the GitHub UI.&lt;/p&gt;
&lt;p&gt;On creating a new release with a specific new version, GitHub creates a tag and automatically runs the &lt;code&gt;Release workflow&lt;/code&gt; defined in .github/workflows/release.yml, given that &lt;code&gt;CI workflow&lt;/code&gt; has run successfully for the current commit on the main branch.&lt;/p&gt;
&lt;p&gt;The set of actions included in the &lt;code&gt;Release workflow&lt;/code&gt; cover:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Generating and verifying QA information&lt;/strong&gt; - actions load the QA information from GitHub artifacts stored for the same commit reference and verify it. Additionally, release documentation is generated and added to the GitHub release. If there is no information available for the current commit, the release workflow will fail.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pull &amp;amp; label container image&lt;/strong&gt; - actions pull the Vehicle App container image based on the current commit hash from the GitHub registry and label it with the specified tag version. If the image cannot be found, the workflow will fail.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Publish to container registry&lt;/strong&gt; - actions publish your container image and helm charts to your preferred container registry, which is referenced by your preferred OTA (over-the-air update) system.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;github-actions-artifacts&#34;&gt;GitHub Actions artifacts&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GitHub Actions artifacts&lt;/strong&gt; are used for storing data, which is generated by the &lt;code&gt;CI workflow&lt;/code&gt; and referenced by the &lt;code&gt;Release workflow&lt;/code&gt;. This saves time during workflow runs because we don&amp;rsquo;t have to create artifacts multiple times.&lt;/p&gt;
&lt;p&gt;GitHub Actions artifacts always have a retention period, which is 90 days per default, but may be configured differently in the specific GitHub organization. After this period, the QA info gets purged automatically. If that is the case, a re-run of the CI workflow is required to re-generate the QA info, afterwards a release can be created.&lt;/p&gt;
&lt;h2 id=&#34;container-registry&#34;&gt;Container Registry&lt;/h2&gt;
&lt;p&gt;The GitHub container registry is used for storing container images, which are generated by the &lt;code&gt;CI workflow&lt;/code&gt; and leveraged by the &lt;code&gt;Release workflow&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;GitHub container registry&lt;/strong&gt; does not have an automatic cleanup and keeps container images as long as they are not deleted. It is recommended that you automate the removal of older images to limit storage size and costs.&lt;/p&gt;
&lt;h2 id=&#34;further-information&#34;&gt;Further information&lt;/h2&gt;
&lt;h3 id=&#34;versioning&#34;&gt;Versioning&lt;/h3&gt;
&lt;p&gt;Vehicle App image versions are set to the Git tag name during release. Though any versioning scheme can be adopted, the usage of &lt;a href=&#34;https://semver.org/&#34;&gt;semantic versions&lt;/a&gt; is recommended.&lt;/p&gt;
&lt;p&gt;If the tag name contains a semantic version, the leading &lt;code&gt;v&lt;/code&gt; will be trimmed.
&lt;strong&gt;Example:&lt;/strong&gt; A tag name of &lt;code&gt;v1.0.0&lt;/code&gt; will lead to version &lt;code&gt;1.0.0&lt;/code&gt; of the Vehicle App container.&lt;/p&gt;
&lt;h3 id=&#34;maintaining-multiple-versions&#34;&gt;Maintaining multiple versions&lt;/h3&gt;
&lt;p&gt;If there is a need to maintain multiple versions of a Vehicle App, e.g., to hotfix the production version while working on a new version at the same time or to support multiple versions in production, create and use &lt;code&gt;release branches&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The release process would be the same as described in the overview, except that a release branch (e.g., &lt;code&gt;release/v1.0&lt;/code&gt;) is created before the release step and the GitHub release is based on the &lt;code&gt;release&lt;/code&gt; branch rather than the &lt;code&gt;main&lt;/code&gt; branch. For hotfixes, release branches may be created retroactively from the release tag, if needed.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Runtime and deployment model</title>
      <link>/velocitas-deocs/docs/concepts/runtime-deployment-model/</link>
      <pubDate>Mon, 09 May 2022 13:43:25 +0530</pubDate>
      
      <guid>/velocitas-deocs/docs/concepts/runtime-deployment-model/</guid>
      <description>
        
        
        &lt;p&gt;The Velocitas project uses a common deployment model. It uses OCI-compliant containers to increase the flexibility for the support of different programming languages and runtimes, which accelerates innovation and development. OCI-compliant containers also allow for a standardized yet flexible deployment process, which increases the ease of operation. Using OCI-compliant is portable to different architectures as long as there is support for OCI-compliant containers on the desired platform (e.g., like a container runtime for arm32, arm64 or amd64).&lt;/p&gt;
&lt;h2 id=&#34;guiding-principles&#34;&gt;Guiding principles&lt;/h2&gt;
&lt;p&gt;The deployment model is guided by the following principles&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Applications are provided as OCI-compatible container images.&lt;/li&gt;
&lt;li&gt;The container runtime offers a Kubernetes-compatible control plane and API to manage the container lifecycle.&lt;/li&gt;
&lt;li&gt;Helm charts are used as deployment descriptor specification.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The template projects provided come with a preconfigured developer toolchain that accelerates the development process. The developer toolchain ensures an easy creation through a high-degree of automation, of all required artifacts which are needed to follow the Velocitas principles.&lt;/p&gt;
&lt;h2 id=&#34;testing-your-container-during-development&#34;&gt;Testing your container during development&lt;/h2&gt;
&lt;p&gt;The Velocitas project provides developers with a repository template and devcontainer that contains everything to build a containerized version of your app locally and test it. Check out our tutorial e.g., for python template (&lt;a href=&#34;https://github.com/eclipse-velocitas/vehicle-app-python-template&#34;&gt;https://github.com/eclipse-velocitas/vehicle-app-python-template&lt;/a&gt;) to learn more.&lt;/p&gt;
&lt;h2 id=&#34;automated-container-image-builds&#34;&gt;Automated container image builds&lt;/h2&gt;
&lt;p&gt;Velocitas uses GitHub workflows to automate the creation of your containerized application. A workflow is started with every increment of your application code that you push to your GitHub repository. The workflow creates a containerized version of your application and stores this container image in a registry. Further actions are carried out using this container (e.g., integration tests).&lt;/p&gt;
&lt;p&gt;The workflows are set up to support multi-platform container creation and generate container images for amd64 and arm64 out of the box. This provides a great starting point for developers and lets you add additional support for further platforms easily.&lt;/p&gt;
&lt;p&gt;Learn more about the concepts of the &lt;a href=&#34;/velocitas-deocs/docs/velocitas/docs/vehicle_app_releases.md&#34;&gt;Velocitas build and release workflows&lt;/a&gt; and check out the example GitHub workflows in our repositories for python (&lt;a href=&#34;https://github.com/eclipse-velocitas/vehicle-app-python-template/blob/main/.github/workflows/ci.yml)&#34;&gt;https://github.com/eclipse-velocitas/vehicle-app-python-template/blob/main/.github/workflows/ci.yml)&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;next-steps&#34;&gt;Next steps&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/velocitas-deocs/docs/getting-started/tutorials/tutorial_how_to_deploy_a_vehicle_app_with_helm/&#34;&gt;Walkthrough: Deploy a Python Vehicle App with Helm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
